/*
 * Copyright (c) 2013-2014 Galois, Inc.
 * Distributed under the terms of the BSD3 license (see LICENSE file)
 */

/* Cryptol specification of the Simon 64/128 block cipher
 * Author: David Lazar
 */

module Simon where

///////////////////////////////////////////////////////////////////////
// round function
///////////////////////////////////////////////////////////////////////

m = 4
j = 3
T = 44

encRound : [32] -> ([32], [32]) -> ([32], [32])
encRound k (x, y) = (y ^ f x ^ k, x)

decRound : [32] -> ([32], [32]) -> ([32], [32])
decRound k (x, y) = (y, x ^ f y ^ k)

f : [32] -> [32]
f x = ((x <<< 1) && (x <<< 8)) ^ (x <<< 2)

///////////////////////////////////////////////////////////////////////
// encryption / decryption
///////////////////////////////////////////////////////////////////////

encrypt : [4][32] -> ([32], [32]) -> ([32], [32])
encrypt k0 b0 = bs ! 0
  where
    bs = [b0] # [ encRound k b | b <- bs | k <- ks ]
    ks = expandKey k0

decrypt : [4][32] -> ([32], [32]) -> ([32], [32])
decrypt k0 b0 = bs ! 0
  where
    bs = [b0] # [ decRound k b | b <- bs | k <- reverse ks ]
    ks = expandKey k0


///////////////////////////////////////////////////////////////////////
// key expansion
///////////////////////////////////////////////////////////////////////

expandKey : [4][32] -> [44][32]
expandKey k0 = k
  where
    k = k0 # [ r where
                    o = k @ (i - 1) >>> 3
                    p = o ^ k @ (i - 3)
                    q = p ^ p >>> 1
                    r = ~ k @ (i - 4) ^ q ^ z ^ 3
                    z = Z @ 3 @ ((i - 4) % 62)
             | (i : [8]) <- [4 .. 43]
             ]

Z : {a} (fin a, a >= 1) => [5][62][a]
Z = [[1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0,
      0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1,
      0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0],
     [1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0,
      0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1,
      0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0],
     [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,
      0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1,
      1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1],
     [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1,
      0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0,
      0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1],
     [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1,
      1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1,
      0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1]]

property correctSimon k b = decrypt k (encrypt k b) == b
property uniqueExpandSimon k1 k2 = (k1 == k2) || (expandKey k1 != expandKey k2)

testKey = [0x1b1a1918, 0x13121110, 0x0b0a0908, 0x03020100]
test = encrypt testKey (0x656b696c, 0x20646e75) == (0x44c8fc20, 0xb9dfa07a)
